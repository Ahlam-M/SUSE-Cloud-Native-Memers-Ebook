# Monoloth vs Microservices


![Monoloth-vs-Microservices](./img/Monoloth-vs-Microservices.jpg)

Another thing that worth mentioning is that testing your application is more difficult, since you have independent services that communicate through an API so when changing anything in a service you have to test it's integration with the rest services.
The consider the main strength of Micro-services is it's ability to recover, means if you have a problem with a given service other part of your application still work normally.
In the other side when using monolithic applications it's easier to test and you could quickly build your project.

![Monoloth-vs-Microservices](./img/Monolith-vs-Microservices-2.png)

When you begin your StartUp Project almost always you start it from the Monolith architecture, by the time the project rises and becomes more popular it could have been very hard for you to support and continue developing. You hire additional developers. Everything resides on a single server, 'app+database' typical stack. Then you face the performance restrictions of your server platform, you should somehow solve it. You rent a bigger one, with more CPU cores, RAM and SSD Storage and it works at that moment, you start thinking of how to gauge and monitor the app's performance (you see the main app's process and its forks eating your resources - a bit hard to say what part of subsystem is eating the most). Your app is being enriched with additional functionality, its codebase becomes more error prone. You think of 3 aims: implementing Agile practices in your Dev Team, plan to refactor your codebase/hiring/promoting SW Architect, hiring/promoting SRE/DevOps Engineer. SW Architect builds a new software design (decision of breaking the Monolith to Microservices is made here), Dev Team is being divided into groups of functionalities. DevOps Engineer prepares CI/CD pipelines, Git branches, containers repository, configures orchestrating tools, prepares sandbox and infrastructure platform for hosting your refactored app. It took some time for the Dev Team for codebase refactoring, but the testing and staging phase completed (logging, metrics and tracing are also being implemented). Transition to the new version is performed. DevOps Engineer deploys monitoring services and logs collector, the visibility of what is working where and how is enabled. Sure it would have been a big work, but the subsequent upgrades and maintenance should work seamlessly. Using the well designed API architecture between services you are able to maintain seperated parts of a whole much more conveniently. You benefit upgrading any part of your software separately - smart update/rollback technics (rolling, canary etc.) of your Kubernetes compatible platform are you helpers, and of course not to end mentioning the performance advantages of automatic horizontally scaling and recovery.

Even the ease testing benefits of monoliths - but really big monolith is also hard to maintain, and the test platform is also would be needed as a perfect scenario for tesing and staging, and what about the developers who is willing to push their changes they made in code, there should be dedicated person who will maintain that pull requests within the whole project repo. Sure you could mention the dev/test etc. branches, but imho especially within the really big and complex project everything should be coordinated and your pull request would have been in a long queue among another requests to be examined and merged and the upgrade of your subsystem depends on other upgrades of another dev-teams - newly released feature updates of a monolith are much slower to release for production. In microservices each service resides in its own git repo - pull requests are serviced much more simple and fast, imho the only disadvantage is sticking to API compliance between services, but only affected services' groups should meet together at Scrum and discussion meetings.

